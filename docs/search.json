{
  "articles": [
    {
      "path": "1-Porque_CPP.html",
      "title": "Por que C++? R não é suficiente?",
      "description": "Mostrar os Benefícios de C++ e quando usá-lo no seu código R\n",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "February 2, 2021",
      "contents": "\n\nContents\nLinguagems Dinâmicas vs Estáticas\nO quão lento R é comparado à C++?\nExemplo - Simples Função de Soma\nExemplo - Amostrador de Gibbs\n\nSobrevoo de C++\nHistória do C++\nTipos de Variáveis – R vs C++\nO qualificador – const\nReferências – &\nFuncões em C++\n\nLoops for em C++\nLoops while em C++\nDesvios condicionais if, else if e else em C++\nCasos condicionais switch\nQuando usar C++ no seu código R?\nO que mais existe em C++?\nAmbiente\n\n\n\nLinguagems Dinâmicas vs Estáticas1\nGeralmente as linguaguens de programação são categorizadas entre linguagens dinamicamente tipadas ou estaticamente tipadas.\nO R é uma liguagem dinamicamente tipada. Isso quer dizer que os tipos das variáveis e dados não são declarados no código e, portanto, conhecidos/checados somente em tempo de execução. Além do R, Ruby, Python e Clojure também são exemplos de linguagens dinamicamente tipadas. A principal vantagem de uma linguagem dinamicamente tipada é a sua agilidade: você se torna mais produtivo e o código mais enxuto, mas isto vem com um custo. A principal desvantagem é que linguagems dinamicamente tipadas são bem mais lentas em tempo de execução.\nO C++ é uma linguagem estaticamente tipada. Isso quer dizer que os tipos das variáveis e dos dados são explicitamente definidos no código e, portanto, conhecidos/checados em tempo de compilação. Além de C++, Java, C#, F#, Kotlin e Go são exemplos de linguagens estaticamente tipadas. A principal vantagem de uma linguagem estaticamente tipada é a sua velocidade em tempo de execução. Sua principal desvantagem é a rigidez: você se torna menos produtivo e o código muito mais verboso.\nO quão lento R é comparado à C++?\nNão conseguimos definir um índice preciso de comparação de tempo de execução entre R, C++ ou qualquer outra linguagem de programação. Isto varia muito conforme aplicação, sistema operacional e tamanho dos dados.\nExemplo - Simples Função de Soma\nComo primeiro exemplo, imagine uma função que soma três números inteiros e retorna o valor da soma. Vamos chamar essa função de add() e compararemos o tempo de execução dessa função em R addR() e em C++ addCpp():\n\n\naddR <- function(x, y, z) {\n    result <- x + y + z\n    return(result)\n}\n\naddR(10, 17, 31)\n\n\n[1] 58\n\n\n\nlibrary(\"Rcpp\")\ncppFunction(\"\nint addCpp(int x, int y, int z){\n   int result = x + y + z;\n   return result;\n}\")\n\naddCpp(10, 17, 31)\n\n\n[1] 58\n\nComparando tempo de execução (em ns) com a função mark() do pacote {bench}:\n\n\nbench::mark(\n  R   = addR(10, 17, 31),\n  Cpp = addCpp(10, 17, 31),\n  time_unit = \"ns\"\n)\n\n\n# A tibble: 2 x 6\n  expression   min median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <dbl>  <dbl>     <dbl> <bch:byt>    <dbl>\n1 R           567.   628.  1534531.    3.81MB        0\n2 Cpp        1541.  3084.   341762.   29.76KB        0\n\nAqui vocês vem que C++ não tem nenhuma vantagem sobre R: é mais verboso, chato de escrever e ainda é mais lenta!\nExemplo - Amostrador de Gibbs\nComo segundo exemplo vamos fazer algo mais computacionalmente intensivo. Para quem não conhece, Amostrador de Gibbs (Gibss Sampler) é um algoritmo de aproximação de uma distribuição probabilística multivariada que usa Método de Montecarlo com correntes Markov; e é primariamente utilizado em casos quando amostragem direta não é possível. Este exemplo foi retirado do blog do Dirk Eddelbuettel mantenedor do ecossitema {Rcpp} de pacotes de interfaces entre R e C++.\nO código em R é assim:\n\n\ngibbsR <- function(N, thin) {\n  mat <- matrix(nrow = N, ncol = 2)\n  x <- y <- 0\n\n  for (i in 1:N) {\n    for (j in 1:thin) {\n      x <- rgamma(1, 3, y * y + 4)\n      y <- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))\n    }\n    mat[i, ] <- c(x, y)\n  }\n  return(mat)\n}\n\n\n\nAgora o código em C++ (não se preocupe agora com os Rcpp que aparecem no código, isto será explicado na segunda parte desse tutorial):\n\n\nsourceCpp(code = \n\"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericMatrix gibbsCpp(int N, int thin) {\n  NumericMatrix mat(N, 2);\n  double x = 0, y = 0;\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < thin; j++) {\n      x = rgamma(1, 3, 1 / (y * y + 4))[0];\n      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];\n    }\n    mat(i, 0) = x;\n    mat(i, 1) = y;\n  }\n\n  return(mat);\n}\"\n)\n\n\n\nE vamos para o benchmark (em µs):\n\n\nbench::mark(\n  R = gibbsR(100, 10),\n  Cpp = gibbsCpp(100, 10),\n  check = FALSE,\n  time_unit = \"us\"\n)\n\n\n# A tibble: 2 x 6\n  expression   min median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <dbl>  <dbl>     <dbl> <bch:byt>    <dbl>\n1 R          3490.  4202.      208.    5.36MB     22.3\n2 Cpp         189.   204.     4715.     4.1KB     36.7\n\nNo meu computador gibbsCpp() executa 20x mais rápido que gibbsR()!\nSobrevoo de C++\nO foco aqui não é ensinar C++. Para isso recomendo você encontrar materiais e cursos que se conformem com o seu estilo de aprendizagem. Eu aprendi com um misto de quatro coisas:\nLivros:\nA Tour of C++: livro de 2018 do criador de C++, Bjarne Stroustrup. É bem conciso e recomendado para quem conhece alguma linguagem de programação orientada a objetos (ex: Python, Java, …).\nC++ Primer: uma das principais referências de C++. Está na quinta edição de 2011. É interessante para aprender o básico de C++ junto com uma introdução à biblioteca padrão (Standard Template Library – STL). Como C++ lança uma nova edição a cada 3 anos, esse livro não possui todas as novas funcionalidades de C++14, C++17 e C++20.\n\nReferências:\ncppreference.com: aqui está a bíblia de C++ totalmente atualizada. Para tudo o que você precisar vale a pena consultar aqui, mas ela é bem técnica. Necessário um certo nível de conhecimento básico em C++ para compreender.\ngeeksforgeeks.com: Geeks for Geeks é um site da Índia sobre programação com uma abordagem mais descontraída. A referência de C++ é bem mais “leve” que a cppreference. Vale a pena para ajudar a entender conceitos que você não tenha entendido pois tem exemplos interessantes.\n\nVídeos no YouTube:\nCppCon: a principal conferência anual sobre C++, todos os vídeos das sessões da conferência são disponibilizados gratuitamente no YouTube.\nCppNow: outra conferência anual sobre C++ com uma pegada mais descontraída e participação da platéia. O vídeo do Conor Hoekstra2 sobre Algorithm Intution é fenomenal.\nMeeting Cpp: outra conferência anual sobre C++, possui bons vídeos com uma pegada similar a CppNow.\nThe Cherno: Um ex-programador de jogos da EA. Ele tem uma didática excelente e eu recomendo a playlist C++ do seu canal.\n\nPodcasts:\nCppCast: podcast de entrevista com desenvolvedores e pessoas de destaque da comunidade C++. Sempre iniciam os episódios comentando com o entrevistado as últimas notícias do mundo C++ e programação em geral.\ncpp.chat: similar ao CppCast.\nADSP: este é um podcast novo e promissor. Seu nome ADSP significa Algorithms + Data Structures = Programs3 e um dos hosts é o Conor Hoekstra programador da NVIDIA e o palestrante do vídeo Algorithm Intution.\n\nHistória do C++\nA linguagem C++ é uma linguagem de programação orientada a objetos e é uma combinação de linguagem de baixo e alto nível – uma linguagem de nível médio. A linguagem de programação foi criada, projetada e desenvolvida por um cientista da computação dinamarquês – Bjarne Stroustrup da Bell Telephone Laboratories (agora conhecida como Nokia Bell Labs) em Murray Hill, New Jersey. Como ele queria uma linguagem flexível e dinâmica que fosse semelhante a C com todos os seus recursos, mas com adicionalidade de verificação de tipo ativa, herança básica, argumento de funcionamento padrão, classes, inlining, etc. e, portanto, C com Classes (C++) foi lançado .\n\n\n\nFigure 1: Bjarne Stroustrup. Figura de: www.wikipedia.org\n\n\n\nC++ era inicialmente conhecido como “C com classes” e foi renomeado C ++ em 1983. ++ é uma abreviação para adicionar um à variedade na programação; portanto, C++ significa aproximadamente que “um maior que C.” Em 1998, foi criado o comitê de padrões C++ que publicou o primeiro padrão internacional ISO para C++, que seria informalmente conhecido como C++98. A cada três anos o comitê de padrões de C++ publica um novo padrão internacional e esses adquirem o sufixo do ano. Até agora temos C++11, C++14, C++17, C++20 e propostas para serem incluídas no C++23.\nO padrão C++11 é importante, tanto que foi seu nome oficial é “o novo padrão C++”. A principal inovação é a biblioteca padrão de C++ (Standard Template Library – STL) que traz quatro componentes chamados algoritmos (algorithms), contêineres (containers), funções (functions) e iteradores (iterators). Os componentes, além de serem revolucionários (C++ pode ser considerado uma linguagem totalmente diferente depois do STL de C++11), são extremamente bem mantidos e documentados. A presença de bugs é quase nula fazendo com que todos os componentes sejam confiáveis e sempre funcionem da maneira que eles foram supostamente projetados para funcionar (a sonda da NASA em Marte possui seu software todo em C++).\nTipos de Variáveis – R vs C++\nOs principais tipos de variáveis de R e sua correspondência em C++ na tabela abaixo. Note que os nomes são bem similares.\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#rsaamwartu .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#rsaamwartu .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 4px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#rsaamwartu .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#rsaamwartu .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#rsaamwartu .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#rsaamwartu .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#rsaamwartu .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#rsaamwartu .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#rsaamwartu .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#rsaamwartu .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#rsaamwartu .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#rsaamwartu .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#rsaamwartu .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#rsaamwartu .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#rsaamwartu .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#rsaamwartu .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#rsaamwartu .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#rsaamwartu .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#rsaamwartu .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#rsaamwartu .gt_left {\n  text-align: left;\n}\n\n#rsaamwartu .gt_center {\n  text-align: center;\n}\n\n#rsaamwartu .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#rsaamwartu .gt_font_normal {\n  font-weight: normal;\n}\n\n#rsaamwartu .gt_font_bold {\n  font-weight: bold;\n}\n\n#rsaamwartu .gt_font_italic {\n  font-style: italic;\n}\n\n#rsaamwartu .gt_super {\n  font-size: 65%;\n}\n\n#rsaamwartu .gt_footnote_marks {\n  font-style: italic;\n  font-size: 65%;\n}\nR\n      C++\n    logical\n\n      bool\n\n    integer\n\n      int\n\n    numeric\n\n      double\n\n    complex\n\n      complex\n\n    character\n\n      string\n\n    \n\nAlém disso, toda linha (instruções e declarações) de C++ deve ser encerrada com um ponto-e-vírgula ;.\nO qualificador – const\nC++ tem diversos tipos de modificadores e qualificadores de variáveis (ex: long, unsigned, volatile, static, etc.). Não vou cobrir todos eles, mas apenas um: const.\nconst significa constante (constant) e é um qualificador usado quando você declara explicitamente que a variável não mudará o seu valor (por mais paradoxal que isso soe…) durante toda a execução do código. Por exemplo se eu tenho um int chamado n_execucao que não mudará o seu valor:\nconst int n_execucao = 10;\nReferências – &\nCada variável que é criada em C++ (e na maioria das outras linguagems de programação) possui um endereço de memória que indica aonde a variável está localizada fisicamente na memória do computador. Esse endereço é como se fosse um código postal indicando aonde conseguimos encontrar a variável. Para criar uma referência usamos o símbolo &. Isto cria uma variável que é uma referência à outra variável e o valor de uma variável referência é o endereço da variável da qual ela referencia. Veja alguns exemplos (obs: // é como comentamos código em C++, equivalente ao # em R):\nint i = 5;  // variável int\nint& j = i; // variável j que é uma referência a i\n&i;         // endereço de memória da variável int i\ni++;        // incrementar i em 1\ni == j;     // TRUE\nj == 5;     // FALSE j agora possui o mesmo valor que i (6)\nPor que usar referências? Por dois motivos:\nPara evitar a cópia de objetos na memória: isso faz o código ficar mais eficiente.\nParamêtros de funções podem especificados por valor ou por referências. No caso de referências, isso é extremamente útil quando queremos alterar os valores dos parâmetros in-place pela função.\nFuncões em C++\nA figura 2 mostra a anatomia de uma função em C++. Ela é bem similar à estrutura de funções no R. Com duas notórias diferenças:\nTipo de Retorno: toda função em C++ deve especificar, antes do seu nome, o tipo de dado que é retornado pela função.\nValor de Retorno: toda função em C++ deve especificar explicitamente qual valor retornar com um return. No R podemos ser mais desleixados pois o valor de retorno será sempre a ultima declaração da função. Em C++ isto não funciona. A lógica de C++ é que a função termina quando ela atinge o primeiro return e retorna o dado/variável especificado(a).\n\n\n\nFigure 2: Anatomia de uma função em C++\n\n\n\nUsando valores vs referências como parâmetros\nÀs vezes é mais eficiente especificar um parâmetro como uma referência do que como um valor. Veja o caso abaixo de uma função simples de incremento de número inteiro. No primeiro caso, a função increment_val() usa o valor do parâmetro x. Isto implica na função gerar uma cópia de x no escopo local da função. Já no segundo caso, a função increment_ref() usa a referência do parâmetro x. Isto não implica em cópia de x, pois a função manipula o parâmetro x no escopo global.\nComo podem ver, nesse cenário simples temos um pequeno ganho, pelo tempo mediano de execução, ao usarmos o a referência como parâmetro. Claro que nesse exemplo a função é trivial, imaginem como essa diferença escalonaria para maior intensidade computacional ou maior entrada de dados. Sem contar que precisamos de ZERO coletor de lixo (garbage collection – gc), pois não estamos movendo/copiando nada para o escopo local da função.\n\n\ncppFunction(\n\"int increment_val(int x){ \n    x++;\n    return x;\n}\"\n)\n\ncppFunction(\n\"int increment_ref(int& x){ \n    x++;\n    return x;\n}\"\n)\n\nbench::mark(\n  value = increment_val(5),\n  reference = increment_ref(5)\n)\n\n\n# A tibble: 2 x 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 value        1.23µs    1.5µs   633044.    2.49KB     63.3\n2 reference    1.23µs   1.45µs   648906.    2.49KB      0  \n\nLoops for em C++\n\nObs: Em C++ todos os índices são baseados em zero. Ou seja, o primeiro elemento de uma array é array[0].\n\nOs loops for de C++ são similares ao de R. Eles seguem a seguinte síntaxe:\nfor (inicialização; condição; incremento) instrução;\nFunciona da seguinte maneira:\nA inicialização é executada. Geralmente, isso declara uma variável de contador (counter) e a define para algum valor inicial. Isso é executado uma única vez, no início do loop.\ncondição é verificada. Se for verdade, o loop continua; caso contrário, o loop termina e a instrução é ignorada, indo diretamente para a etapa 5.\ninstrução é executada. Como de costume, pode ser uma única instrução ou um bloco entre chaves {}.\nincremento é executado e o loop volta para a etapa 2.\no loop termina: a execução continua na próxima instrução após ela.\nVeja um exemplo4:\nfor (int i=0; i < 5; i++) {\n      cout << i << \"\\n\";\n    }\nC++11 introduziu uma funcionalidade chamada de range-for loop para ser usado com principalmente com os contêineres da C++11 STL, simplificando muito mais a síntaxe:\nfor (declaração : expressão)\n    instrução\ndeclaração - define uma variável. Deve ser possível converter cada elemento da sequência para o tipo da variável. A maneira mais fácil de garantir que os tipos correspondam é usar o especificador de tipo auto.\nexpressão - deve representar uma sequência, como uma lista de inicializadores entre chaves, um array ou um objeto como umvector ou string que tem membros begin e end que retornam iteradores.\nExemplo:\nvector<int> a {1, 2, 3, 4, 5};\n\nfor (auto i: a) {\n  cout << i << endl;\n}\nCompare com o for loop tradicional (muito mais verboso):\nvector<int> a {1, 2, 3, 4, 5};\n\nfor(int i=0; i < a.size(); i++){\n   cout << a[i] << endl;\n}\nLoops while em C++\nLoops while em C++ são quase que idênticos aos do R. Veja um exemplo:\nint i = 0;\n\nwhile (i < 10){\n    i++;\n    cout << i << \"\\n\";\n}\nDesvios condicionais if, else if e else em C++\nDesvios condicionais em C++ são também quase que idênticos aos do R. Veja um exemplo:\nint i = 2;\n\nif (i > 2) {\n    cout << i << \" é maior que 2\\n\";\n} else if (i == 2){\n    cout << i << \" é extamente igual a 2\\n\";\n} else {\n    cout << i << \" é menor que 2\\n\";\n}\nCasos condicionais switch\nOs casos condicionais usando o operador switch em C++ é também muito similar ao R. A única diferença é que ao invés de = temos : para especificar os casos, veja a síntaxe:\nswitch(i) {\n  case 1 : cout << '1';           // imprime \"1\"\n  case 2 : cout << '2';           // imprime \"2\"\n  default : cout << \"default\\n\";    // imprime \"default\"\n}\nQuando usar C++ no seu código R?\nOs gargalos típicos que C++ pode resolver incluem:\nLoops que não podem ser facilmente vetorizados porque as iterações subsequentes dependem das anteriores.\nFunções recursivas ou problemas que envolvem a chamada de funções milhões de vezes. A sobrecarga de chamar uma função em C++ é muito menor do que em R.\nProblemas que exigem estruturas de dados (contêineres) e algoritmos avançados que R não fornece. Por meio da biblioteca padrão (STL), C++ tem implementações eficientes de muitas estruturas de dados importantes, de mapas ordenados (ordered maps) a filas duplas (double-ended queues).\nEsses contextos são todos os cenários que C++ pode ajudar o seu código. “Nem mesmo os mais sábios sabem o fim de todos os caminhos”5.\n\n\n\nO que mais existe em C++?\nNesse breve sobrevoo de C++ a intenção é apenas possibilitar alguém que não tenha nenhum conhecimento em C++ à ser introduzido em alguns conceitos de C++, notoriamente focando em funções (eu acredito ser a principal razão de usarmos C++ em R – acelerar o tempo de execução de funcões). Usando uma analogia, esse sobrevoo permite o leitor “dirigir C++ por um estacionamento vazio”. Caso se interesse, C++ é uma linguagem EXTREMAMENTE rica e complexa. Veja os livros, referências, vídeos e podcasts que eu recomendei lá em cima.\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.3 (2020-10-10)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] dplyr_1.0.2 gt_0.2.2    Rcpp_1.0.5 \n\nloaded via a namespace (and not attached):\n [1] pillar_1.4.7     compiler_4.0.3   highr_0.8       \n [4] tools_4.0.3      digest_0.6.27    downlit_0.2.1   \n [7] checkmate_2.0.0  gtable_0.3.0     evaluate_0.14   \n[10] lifecycle_0.2.0  tibble_3.0.4     png_0.1-7       \n[13] pkgconfig_2.0.3  rlang_0.4.10     bench_1.1.1     \n[16] cli_2.2.0        commonmark_1.7   distill_1.1     \n[19] yaml_2.2.1       parallel_4.0.3   xfun_0.20       \n[22] stringr_1.4.0    knitr_1.30       sass_0.2.0      \n[25] generics_0.1.0   vctrs_0.3.6      grid_4.0.3      \n[28] tidyselect_1.1.0 glue_1.4.2       R6_2.5.0        \n[31] jpeg_0.1-8.1     fansi_0.4.1      profmem_0.6.0   \n[34] rmarkdown_2.6    purrr_0.3.4      ggplot2_3.3.3   \n[37] magrittr_2.0.1   backports_1.2.1  scales_1.1.1    \n[40] ellipsis_0.3.1   htmltools_0.5.0  assertthat_0.2.1\n[43] colorspace_2.0-0 utf8_1.1.4       stringi_1.5.3   \n[46] munsell_0.5.0    crayon_1.3.4    \n\n\nJulia é um caso a parte pois pode ser tanto codificada de maneira estática quando dinâmica, mas isso é assunto para outro tutorial.↩︎\num dos hosts do podcast ADSP.↩︎\nAlgoritmos + Estruturas de Dados = Programas.↩︎\naqui estamos usando o cout do <iostream>. Explicarei como printar mensagens no R usando C++ na segunda parte desse tutorial↩︎\num dos meus objetivos era incluir no mínimo uma referência de Star Wars (já feita no Home) e uma de Senhor dos Anéis↩︎\n",
      "last_modified": "2021-01-10T07:44:35-03:00"
    },
    {
      "path": "2-Rcpp.html",
      "title": "Como incorporar C++ no R -- `{Rcpp}`",
      "description": "Como usar o `{Rcpp}` para funções em C++ no R\n",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "February 2, 2021",
      "contents": "\n\nContents\nCriando funções em C++ no R\nsourceCpp()\ncppFunction()\n\nComo exibir mensagens e erros em funções {Rcpp}\nCancelando a Execução no {Rcpp}\nTipos de Dados e Variáveis do {Rcpp}\n{Rcpp} – Vector\n{Rcpp} – Matrix\n{Rcpp} – List\n{Rcpp} – DataFrame\n\nExemplo – Multiplicação de Matrizes\nUsando a biblioteca padrão C++11 STL no {Rcpp}\nExemplo – std::transforme_reduce()\n\n{Rcpp} e Boost\nExemplo – Máximo Divisor Comum\n\n{Rcpp} e Rmarkdown\nUsar {Rcpp} no seu pacote R\nMateriais Adicionais de Consulta\nAmbiente\n\n\n\nA maneira mais fácil e simples de usar código C++ no R é pelo pacote {Rccp}. O primeiro passo é importar o pacote:\n\n\nlibrary(Rcpp)\n\n\n\nCriando funções em C++ no R\nNo {Rcpp} é possível criarmos funções de duas maneiras1, sendo que ambas retornam as funções criadas em C++ para o ambiente do R:\nsourceCpp(): lê código C++ de um arquivo .cpp ou de uma string.\ncppFunction(): cria uma função C++ de uma string.\nsourceCpp()\nTodo código C++ que é utilizado pelo {Rcpp} deve começar com duas instruções no arquivo (ou string do código):\n#include <Rcpp.h>\nusing namespace Rcpp;\n#include <Rcpp.h> – indica que deve ser incluído o cabeçalho (header) do {Rcpp} no arquivo. Isto permite com que o código faça a interface com o R usando o {Rcpp}.\nusing namespace Rcpp; – importa todos os nomes que estão incluídos dentro da biblioteca {Rcpp}. Para os que tem TOC gostam de boas práticas, não é recomendável importar todos nomes de uma namespace em C++. Isto evita conflitos de nome. Caso queira usar algo de uma namespace você pode fazer de duas maneiras:\nNão importando a namespace e acessar o nome desejado da namespace com os quatro pontos (::). Exemplo:\nRcpp::List // toda vez que usar List tem que indicar que é o List do Rcpp.\nImportando apenas o nome desejado da namespace com o using. Exemplo:\nusing Rcpp::List;\nList  // toda vez que você digitar List C++ entende que é o List do Rcpp.\nAlém disso, para cada função que for criada no código C++ é necessário incluir o // [[Rcpp::export]] logo acima da função. Isto é necessário pois indica ao {Rcpp} que a função deve ser exportada de volta para uso no ambiente do R. No exemplo abaixo criei uma função addCpp() logo depois do Rcpp::export:\n// [[Rcpp::export]]\nint addCpp(int x, int y, int z){\n   int result = x + y + z;\n   return result;\n}\nHá duas maneiras de usar sourceCpp(): fornecendo um arquivo .cpp ou um código C++ como string.\nsourceCpp() – Usando um arquivo .cpp\nCriei um arquivo chamado addCpp.cpp com o código C++ pronto para ser usado pelo {Rcpp} com o sourceCpp(). Note que inclui um bloco de código R que automaticamente será executado após a compilação do arquivo. O ideal é inserir esses blocos de código R na parte final dos seus arquivos .cpp.\n\n\nwriteLines(readLines(\"addCpp.cpp\"))\n\n\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nint addCpp(int x, int y, int z){\n  int result = x + y + z;\n  return result;\n}\n\n\n// Você pode incluir blocos de códigos de R em código C++\n// (útil para testagem e desenvolvimento). O código R será\n// automaticamente executado após a compilação.\n//\n\n/*** R\naddCpp(11, 21, 31)\n*/\n\n\n\nsourceCpp(file = \"addCpp.cpp\")\n\n\n\n> addCpp(11, 21, 31)\n[1] 63\n\nsourceCpp() – Usando uma string\nDa mesma maneira que usamos sourceCpp() para um arquivo .cpp, também é possível usar uma string em código C++. Abaixo o mesmo exemplo anterior, mas usando uma string:\n\n\nsourceCpp(code = \"\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nint addCpp(int x, int y, int z){\n  int result = x + y + z;\n  return result;\n}\n\n/*** R\naddCpp(11, 21, 31)\n*/\n\")\n\n\n\n> addCpp(11, 21, 31)\n[1] 63\n\ncppFunction()\ncppFunction() faz a mesma coisa que sourceCpp(): retorna uma função criada em C++ para o ambiente do R. Mas com uma pequena diferença: você pode omitir todas as instruções do {Rcpp} – o #include <Rcpp.h>, using namespase Rcpp; e // [[Rcpp::export]].\nUsarei o mesmo exemplo do sourceCpp(), sendo que agora não preciso mais incluir as instruções do {Rcpp}:\n\n\ncppFunction(\"\nint addCpp(int x, int y, int z){\n  int result = x + y + z;\n  return result;\n}\n\")\n\naddCpp(1, 2, 4)\n\n\n[1] 7\n\nComo exibir mensagens e erros em funções {Rcpp}\nTradicionalmente, em C++, usamos o cabeçalho <iostream> da C++11 STL para imprimir na tela mensagens (cout) e erros cerr:\n#include <iostream>\nusing std::cout;\nusing std::cerr;\n\ncout << \"Imprima algo na tela\\n\";\ncerr << \"Imprima um erro na tela\\n\";\nIsto não funciona muito bem quando executamos uma função C++ no R com o {Rcpp}. Para isso existem dois objetos na namespace Rcpp: Rcout e Rcerr. Veja um exemplo:\n\n\nwriteLines(readLines(\"teste_print.cpp\"))\n\n\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nvoid teste_print(){\n  Rcout << \"Imprima algo na tela\\n\";\n  Rcerr << \"Imprima um erro na tela\\n\";\n}\n\n\n\nsourceCpp(\"teste_print.cpp\")\nteste_print()\n\n\nImprima algo na tela\n\nCancelando a Execução no {Rcpp}\nA função CheckUserInterrupt() do {Rcpp} verifica se o botão ctrl + c foi pressionado e, se for pressionado, interromperá a execução da função.\nSe você quiser executar um cálculo que leve muito tempo, seria melhor executar checkUserInterrupt() aproximadamente uma vez a cada poucos segundos. Veja este exemplo de um loop for:\nfor (int i=0; i<100000; ++i) {\n    // Checando interrupção a cada 1000 iterações\n    if (i % 1000 == 0){\n        Rcpp::checkUserInterrupt();\n    }\n\n    // instruções do loop ...\n}\nTipos de Dados e Variáveis do {Rcpp}\nTemos sete tipos de variáveis que são usualmente usados no R: logical, integer, numeric,complex, character, Date e POSIXct. Sendo que esses sete tipos são usados no R para construir vetores (arrays 1-D) e matrizes (arrays 2-D). Apenas um lembrete:\n\n\nvec_int <- c(1L, 2L, 3L, 4L)\nstr(vec_int)\n\n\n int [1:4] 1 2 3 4\n\nmat_num <- matrix(c(1.1, 2.2, 3.3, 4.4), nrow = 2, ncol = 2)\nstr(mat_num)\n\n\n num [1:2, 1:2] 1.1 2.2 3.3 4.4\n\n{Rcpp} possui tipos de vetores e matrizes para representar correspondentemente aos do R.\nA tabela abaixo apresenta a correspondência dos tipos de dados entre R/{Rcpp}/C++:\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#yeqqjqczwf .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#yeqqjqczwf .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 4px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#yeqqjqczwf .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#yeqqjqczwf .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#yeqqjqczwf .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#yeqqjqczwf .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#yeqqjqczwf .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#yeqqjqczwf .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#yeqqjqczwf .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#yeqqjqczwf .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#yeqqjqczwf .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#yeqqjqczwf .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#yeqqjqczwf .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#yeqqjqczwf .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#yeqqjqczwf .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#yeqqjqczwf .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#yeqqjqczwf .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#yeqqjqczwf .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#yeqqjqczwf .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#yeqqjqczwf .gt_left {\n  text-align: left;\n}\n\n#yeqqjqczwf .gt_center {\n  text-align: center;\n}\n\n#yeqqjqczwf .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#yeqqjqczwf .gt_font_normal {\n  font-weight: normal;\n}\n\n#yeqqjqczwf .gt_font_bold {\n  font-weight: bold;\n}\n\n#yeqqjqczwf .gt_font_italic {\n  font-style: italic;\n}\n\n#yeqqjqczwf .gt_super {\n  font-size: 65%;\n}\n\n#yeqqjqczwf .gt_footnote_marks {\n  font-style: italic;\n  font-size: 65%;\n}\nTipo de Variável\n      Vetor R\n      Vetor Rcpp\n      Matriz Rcpp\n      Escalar Rcpp\n      Escalar C++\n    Lógica\n\n      logical\n\n      LogicalVector\n\n      LogicalMatrix\n\n      -\n\n      bool\n\n    Inteiro\n\n      integer\n\n      IntegerVector\n\n      IntegerMatrix\n\n      -\n\n      int\n\n    Real\n\n      numeric\n\n      NumericVector\n\n      NumericMatrix\n\n      -\n\n      double\n\n    Complexo\n\n      complex\n\n      ComplexVector\n\n      ComplexMatrix\n\n      Rcomplex\n\n      complex\n\n    String\n\n      character\n\n      CharacterVector (StringVector)\n\n      CharacterMatrix (StringMatrix)\n\n      String\n\n      std::string\n\n    Date\n\n      Date\n\n      DateVector\n\n      -\n\n      Date\n\n      -\n\n    Datetime\n\n      POSIXct\n\n      DatetimeVector\n\n      -\n\n      Datetime\n\n      time_t\n\n    \n\nAlém de vetores e matrizes, {Rcpp} também possui as estrutura de dados correspondentes ao data.frame e list:\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#ucvexzxnqr .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#ucvexzxnqr .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 4px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#ucvexzxnqr .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#ucvexzxnqr .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#ucvexzxnqr .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#ucvexzxnqr .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#ucvexzxnqr .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#ucvexzxnqr .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#ucvexzxnqr .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#ucvexzxnqr .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#ucvexzxnqr .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#ucvexzxnqr .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#ucvexzxnqr .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#ucvexzxnqr .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ucvexzxnqr .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#ucvexzxnqr .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#ucvexzxnqr .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#ucvexzxnqr .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#ucvexzxnqr .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#ucvexzxnqr .gt_left {\n  text-align: left;\n}\n\n#ucvexzxnqr .gt_center {\n  text-align: center;\n}\n\n#ucvexzxnqr .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#ucvexzxnqr .gt_font_normal {\n  font-weight: normal;\n}\n\n#ucvexzxnqr .gt_font_bold {\n  font-weight: bold;\n}\n\n#ucvexzxnqr .gt_font_italic {\n  font-style: italic;\n}\n\n#ucvexzxnqr .gt_super {\n  font-size: 65%;\n}\n\n#ucvexzxnqr .gt_footnote_marks {\n  font-style: italic;\n  font-size: 65%;\n}\nR\n      Rcpp\n    data.frame\n\n      DataFrame\n\n    list\n\n      List\n\n    \n\nNo {Rcpp}, Vector, DataFrame, List são todos implementados como tipos de vetores. Ou seja, Vector é um vetor em que seus elementos são valores escalares, DataFrame é um vetor em que seus elementos são Vector, List é um vetor em que seus elementos são qualquer tipo de tipo de dados. Portanto, Vector, DataFrame, List tem muitas funcionalidades em comum.\nMuito importante: {Rcpp} converterá qualquer tipo de retorno das funções para o seu respectivo tipo em R. Por exemplo, NumericVector será convertido para um vetor de numeric no R. Assim como LogicalMatrix será convertida para uma matriz de logical no R.\n{Rcpp} – Vector\nVector no {Rcpp} são arrays 1-D com tamanho dinâmico (não-estático). Note que Vector é um objeto dentro do namespace Rcpp.\nCriando Objetos de Vector\nVeja alguns exemplos de como criar objetos de Vector com o código em R correspondente comentado com //:\n// Crie um objeto Vector equivalente a\n// v <- rep(0, 3)\nNumericVector v (3);\n\n// v <- rep(1, 3)\nNumericVector v (3,1);\n\n// v <- c(1,2,3) \n// C++11 Inicialização em Lista\nNumericVector v = {1,2,3}; \n\n// v <- c(1,2,3)\nNumericVector v = NumericVector::create(1,2,3);\n\n// v <- c(x=1, y=2, z=3)\nNumericVector v =\nNumericVector::create(Named(\"x\",1), Named(\"y\")=2 , _[\"z\"]=3);\na função Rcpp::Named() é usada para criar vetores (e outros objetos) nomeados e há 3 variações conforme demonstrado acima.\nAcessando Elementos de Vector\nVocê pode acessar um elemento individual de um objeto Vector usando o operador [] ou ()2 Ambos os operadores aceitam NumericVector/IntegerVector (índice numérico), CharacterVector (nomes de elementos) e LogicalVector. O operador [] ignora o acesso fora do limite, enquanto o operador () lança uma exceção index_out_of_bounds.\nVocê pode também usar o método .names() do Vector para designar nomes ao elementos.\n// Criando o Vector v\nNumericVector v  {10,20,30,40,50};\n\n// Designando nomes dos elementos\nv.names() = CharacterVector({\"A\",\"B\",\"C\",\"D\",\"E\"});\n\n// Extraindo valores dos elementos de Vector\ndouble x1 = v[0];\ndouble x2 = v[\"A\"];\n\n// Designando valores aos elementos de Vector\nv[0]   = 100;\nv[\"A\"] = 100;\nMétodos de Vector\nAbaixo um exemplo dos principais métodos de Vector3. Lembrando que muitas dessas funcionalidades são compartilhadas com Matrix, List e DataFrame. Para uma lista completa dos métodos das classes de {Rcpp} recomendo a documentação não-oficial de {Rcpp} do James Balamuta (também conhecido como TheCoatlessProfessor).\nlength(), size()\nnames()\nfill(x)\nsort()\npush_back(x), push_front(x), insert(i, x), erase(i)\nOperações com Vector\nAlém de métodos, os elementos Vector possuem alguns operadores:\nadição, subtração, multiplicação, divisão: +,-, *, /\nigualdade e desigualdades: ==, !=, <, >, >=, <=\nnegação: !\n{Rcpp} – Matrix\nMatrix no {Rcpp} são arrays 2-D com tamanho estático. Note que Matrix é um objeto dentro do namespace Rcpp.\nA criação dos objetos Matrix é similar à criação de objetos Vector. Veja alguns exemplos de como criar objetos de Matrix com o código em R correspondente comentado com //:\n// Criação de um objeto Matrix equivalente a\n// m <- matrix(0, nrow=2, ncol=2)\nNumericMatrix m1(2);\n\n// m <- matrix(0, nrow=2, ncol=3)\nNumericMatrix m2(2 , 3);\nVocê pode acessar os elementos da mesma forma que Vector. Além disso, um objeto Matrix em R é na verdade um vetor cujo número de linhas e colunas é definido no atributo dim. Portanto, se você criar um vetor com o atributo dim em {Rcpp} e devolvê-lo a R, ele será tratado como uma matriz:\n// Criação de um objeto Vector\nNumericVector v = {1,2,3,4};\n\n// Designa o número de linhas e colunas no atributo dim do objeto Vector\nv.attr(\"dim\") = Dimension(2, 2);\n\n// Valor de retorno. Será tratado como uma matriz no R\nreturn v;\n{Rcpp} – List\nEm {Rcpp}, objetos List são implementados como uma espécie de Vector. Em outras palavras, Vector é um vetor cujo elemento é um valor escalar, enquanto List é um vetor cujos elementos são quaisquer tipos de dados. Portanto, Vector e List geralmente têm as mesmas funcionalidades.\nPara criar um objeto List, usamos a função List::create(). Além disso, para especificar o nome do elemento ao criar List, use a função Named()ou _[]:\n// Criação de um objeto List L dos vetores v1, v2\nList L = List::create(v1, v2);\n\n// Criação atribuindo nomes aos elementos da Lista L\nList L = List::create(Named(\"nome1\") = v1 , _[\"nome2\"] = v2);\n{Rcpp} – DataFrame\nEm {Rcpp}, objetos DataFrame também são implementados como uma espécie de Vector. Em outras palavras, Vector é um vetor cujos elementos são valores escalares e DataFrame é um vetor cujos elementos são Vector. Portanto, DataFrame tem muitas funcionalidades em comum com Vector.\nDataFrame::create() é usado para criar um objeto DataFrame. Além disso, use Named() ou _[] se desejar especificar os nomes das colunas ao criar o objeto DataFrame:\n// Criação de um objeto DataFrame df dos vetores v1, v2\nDataFrame df = DataFrame::create(v1, v2);\n\n// Criação atribuindo nomes às colunas de DataFrame df\nDataFrame df = DataFrame::create( Named(\"V1\") = v1 , _[\"V2\"] = v2 );\nExemplo – Multiplicação de Matrizes\nEstá na hora de colocarmos o que vimos em prática. Nesse caso vamos comparar multiplicar duas matrizes usando o R (operador %*%) e usando o C++ com {Rcpp}.\n\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector mat_mul(const NumericVector& A, const NumericVector& B) {\n  NumericVector C = A * B;\n  \n  // dimensões para Vector virar Matrix no R\n  int dim = sqrt(A.length());\n  C.attr(\"dim\") = Dimension(dim, dim);\n  \n  return C;\n}\n\n\n\nn <- 10^3\nX <- matrix(rnorm(n * n), nrow = n)\n\nbench::mark(\n  R = X %*% X,\n  Cpp = mat_mul(X, X),\n  check = FALSE\n)\n\n\n# A tibble: 2 x 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 R           653.9ms 653.91ms      1.53    7.63MB       0 \n2 Cpp           1.2ms   1.26ms    597.      7.63MB     153.\n\nSucesso! Ganho de 700x 🤯 para uma matriz de dimensão 1.000 x 1.000!\nUsando a biblioteca padrão C++11 STL no {Rcpp}\nCaso queira usufruir da biblioteca padrão C++11 STL no {Rcpp} é simples: basta incluir // [[Rcpp::plugins(\"cpp11\")]] em qualquer parte do seu código C++.\nCaso queira usufruir da biblioteca padrão C++20 STL no {Rcpp} é também simples: basta incluir // [[Rcpp::plugins(\"cpp2a\")]]4 em qualquer parte do código C++.\nExemplo – std::transforme_reduce()\nAqui eu vou ser um pouco abusado no exemplo e já vou pular direto para um algoritmo relativamente novo no mundo da STL de C++ (e um dos meus preferidos…). No mundo das linguagens de programação ele é conhecimento como MapReduce, mas em C++ chama-se transform_reduce() e está disponível no header <numeric> desde C++17.\nSoma dos quadrados é algo que ocorre bastante em computação científica, especialmente quando estamos falando de regressão, mínimos quadrados, ANOVA etc. Vamos fazer três implementações de uma função que aceita como parâmetro um vetor de números reais (C++ double / R numeric) e computa a soma de todos os elementos do vetor elevados ao quadrado:\nsum_of_squares_R(): feita no R com vetorização usando o {purrr}.\nsum_of_squares_rcpp(): feita de maneira ingênua no C++ com dois loops for triviais que (1) multiplica cada elemento consigo mesmo e (2) adiciona todos os elementos do vetor à uma variável double.\nsum_of_squares_cpp20(): solução elegante que usa transform_reduce para transformar todos os elementos multiplicando-os por si mesmos e ao mesmo tempo somando todos os elementos.\n\n\nlibrary(magrittr)\nsum_of_squares_R <- function(v) {\n  purrr::map_dbl(v, ~ .x * .x) %>% \n    purrr::reduce(`+`)\n}\n\n\n\n\n#include <Rcpp.h>\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::plugins(\"cpp2a\")]]\n#include <numeric>\n\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum_of_squares_rcpp(NumericVector& v){\n  int sum_of_elems = 0;\n  \n  // primeiro for multiplicando cada elemento consigo mesmo\n  for(int i=0; i < v.size(); i++){\n    v[i] = v[i] * v[i];\n  }\n  \n  // segundo for somando todos os elementos\n  for(auto it = v.cbegin(); it != v.cend(); ++it)\n    sum_of_elems += *it;\n  return sum_of_elems;\n}\n\n// [[Rcpp::export]]\ndouble sum_of_squares_cpp20(const NumericVector& v){\n  \n  return transform_reduce(v.cbegin(),\n                          v.cend(),\n                          0L,\n                          std::plus{},\n                          [] (auto i) {return i * i;});\n}\n\n\n\nset.seed(123)\nn <- 1000\nv <- rnorm(n)\nbench::mark(\n  R = sum_of_squares_R(v),\n  rcpp = sum_of_squares_rcpp(v),\n  cpp20 = sum_of_squares_cpp20(v),\n  check = FALSE,\n  time_unit = \"us\"\n)\n\n\n# A tibble: 3 x 6\n  expression     min  median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>   <dbl>   <dbl>     <dbl> <bch:byt>    <dbl>\n1 R          3265.   3560.        273.  228.41KB     15.5\n2 rcpp          9.01    9.27   101791.    2.49KB      0  \n3 cpp20         5.34    5.58   169664.    2.49KB     17.0\n\nMais um sucesso! Ganho de 600x 🤯 para um vetor com 1.000 elementos! O mais impressionante é que uma solução simples e ingênua com dois loops for em C++ ficou quase tão rápida quanto uma solução C++ usando transform_reduce()!\n{Rcpp} e Boost\nBoost é um conjunto de bibliotecas para a linguagem de programação C++ que fornece suporte para tarefas e estruturas como álgebra linear, geração de números pseudo-aleatórios, multithreading, processamento de imagem, expressões regulares e teste de unidade. Ele contém uma porrada 164 bibliotecas individuais (versão 1.75) e sua versão inicial foi lançada em 1999.\nA maioria das bibliotecas Boost são licenciadas sob a Licença de Software Boost, projetada para permitir que Boost seja usado com projetos de software proprietários e gratuitos. Muitos dos fundadores da Boost estão no comitê internacional de padrões C++, e várias bibliotecas Boost foram aceitas para incorporação no padrão C++11 (por exemplo, smart pointers, thread, regex, random, ratio, tuple) e no padrão C ++ 17 (por exemplo, filesystem, any, optional, variant, string_view).\nAntes de usar o Boost no {Rcpp} certifique-se que você tem o Boost instalado no seu sistema operacional:\nLinux: sudo apt-get install libboost-all-dev\nMacOS: brew install boost\nWindows: baixe no site do Boost.org ou choco install boost-msvc-14.1\nPara usar o Boost no {Rcpp} também é muito simples:\nCertifique-se que você tem o pacote {BH} (Boost Headers) de R instalado.\nInclua a síntaxe // [[Rcpp::depends(BH)]] em qualquer lugar do seu código C++.\nInclua o header que deseja usar do boost no topo do seu código C++. Ex: #include <boost/header_qualquer.hpp>\nExemplo – Máximo Divisor Comum\nO Máximo Divisor Comum (MDC), em inglês Greatest Common Divisor (GCD), de dois ou mais inteiros, que não são todos zero, é o maior inteiro positivo que divide cada um dos inteiros. Três abordagens:\nrGDCD(): R usando o algoritmo de Euclides.\ncppGCD(): C++ usando std::gcd() do header <numeric> (C++17).\nboostGCD(): C++ usando a biblioteca boost::integer.\n\n\nrGCD <- function(a, b) {\n  if (a == 0) {\n    b\n  }\n  else {\n    rGCD(b %% a, a)\n  }\n}\n\n\n\n\n#include <Rcpp.h>\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::plugins(\"cpp17\")]]\n// [[Rcpp::depends(BH)]]\n#include <numeric>\n#include <boost/integer/common_factor_rt.hpp>\n\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nint cppGCD(int& a, int& b){\n  return std::gcd(a, b);\n}\n \n// [[Rcpp::export]]\nint boostGCD(int& a, int& b) {\n    return boost::integer::gcd(a, b);\n}\n\n\n\na <- 7919\nb <- 7412\nbench::mark(\n  R = rGCD(a, b),\n  cpp = cppGCD(a, b),\n  boost = boostGCD(a, b)\n)\n\n\n# A tibble: 3 x 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 R            6.96µs   7.61µs   111113.   15.69KB     11.1\n2 cpp           1.5µs   1.77µs   453089.    2.49KB      0  \n3 boost        1.49µs   1.69µs   533057.    2.49KB     53.3\n\nAqui eu escolhi um número primo bem grande, 7189, e um número aleatório próximo dele, 7412. Como vocês podem ver a solução usando a biblioteca boost::integer é 4,5x mais rápida que uma implementação em R e similar com a implementação de C++17.\n{Rcpp} e Rmarkdown\nPara usar o {Rcpp} em documentos markdown basta colocar Rcpp no chunk ao invés de r. Sendo que no Rmarkdown não é necessário incluir as instruções do {Rcpp} – o #include <Rcpp.h> ou using namespace Rcpp;, isto já é feito automático para você.\n\n\nknitr::include_graphics(\"images/rcpp-rmarkdown.png\")\n\n\n\n\nFigure 1: {Rcpp} no Rmarkdown\n\n\n\nUsar {Rcpp} no seu pacote R\nPara adicionar {Rcpp} a um pacote existente, coloque seus arquivos C++ no diretório src/ e crie ou modifique os seguintes arquivos de configuração:\nNo DESCRIPTION adicione:\nLinkingTo: Rcpp\nImports: Rcpp\nCertifique-se de que seu NAMESPACE inclua:\nuseDynLib(mypackage)\nimportFrom(Rcpp, sourceCpp)\nA maneira mais fácil de configurar isso automaticamente é usar a função usethis::use_rcpp().\nAntes de dar build do pacote, você precisará executar Rcpp::compileAttributes(). Esta função verifica os arquivos C++ em busca de atributos Rcpp::export e gera o código necessário para disponibilizar as funções em R. Execute novamente compileAttributes() sempre que as funções forem adicionadas, removidas ou seus nomes forem alterados. Isso é feito automaticamente pelo pacote devtools e pelo Rstudio.\nPara obter mais detalhes, consulte a vinheta do pacote {Rcpp}, vignette(\"Rcpp-package\").\nMateriais Adicionais de Consulta\nDiversos materiais me ajudaram a aprender e criar esse conjunto de tutoriais de {Rcpp}:\nLivro Seamless R and C++ Integration with Rcpp do criador do ecossitema {Rcpp} Dirk Eddelbuettel.\nCapítulo 25 – Rewriting R code in C++ do livro Advanced R do Hadley Wickham.\nGaleria de exemplos de {Rcpp}.\nLivro Rcpp for Everyone do Masaki E. Tsuda.\nDocumentação Não-Oficial de {Rcpp} do James Balamuta (também conhecido como TheCoatlessProfessor).\nVídeo do Dirk Eddelbuettel na conferência useR! 2020 sobre {Rcpp}.\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.3 (2020-10-10)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] magrittr_2.0.1 dplyr_1.0.2    gt_0.2.2       Rcpp_1.0.5    \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.1.0  xfun_0.20         purrr_0.3.4      \n [4] colorspace_2.0-0  vctrs_0.3.6       generics_0.1.0   \n [7] htmltools_0.5.0   emo_0.0.0.9000    yaml_2.2.1       \n[10] utf8_1.1.4        rlang_0.4.10      pillar_1.4.7     \n[13] glue_1.4.2        jpeg_0.1-8.1      lifecycle_0.2.0  \n[16] stringr_1.4.0     munsell_0.5.0     commonmark_1.7   \n[19] gtable_0.3.0      bench_1.1.1       evaluate_0.14    \n[22] knitr_1.30        parallel_4.0.3    fansi_0.4.1      \n[25] profmem_0.6.0     highr_0.8         scales_1.1.1     \n[28] backports_1.2.1   checkmate_2.0.0   jsonlite_1.7.2   \n[31] distill_1.1       ggplot2_3.3.3     png_0.1-7        \n[34] digest_0.6.27     stringi_1.5.3     bookdown_0.21    \n[37] grid_4.0.3        rprojroot_2.0.2   BH_1.72.0-3      \n[40] cli_2.2.0         tools_4.0.3       sass_0.2.0       \n[43] tibble_3.0.4      crayon_1.3.4      pkgconfig_2.0.3  \n[46] downlit_0.2.1     ellipsis_0.3.1    lubridate_1.7.9.2\n[49] assertthat_0.2.1  rmarkdown_2.6     rstudioapi_0.13  \n[52] R6_2.5.0          compiler_4.0.3   \n\n\ntem também o evalCpp() mas não vou cobrir aqui↩︎\nlembrando que C++ os índices começam em zero: então o primeiro elemento é Vector[0].↩︎\nquem conhece C++, em especial a C++11 STL, pode ver que muitos métodos de Vector são iguais à std::vector.↩︎\nverifique também como instalar um compilador C++ que dê suporte ao C++20 (talvez o g++ versão 10).↩︎\n",
      "last_modified": "2021-01-10T07:44:35-03:00"
    },
    {
      "path": "3-RcppEigen_RcppArmadillo.html",
      "title": "Manipulação de Matrizes -- `{RcppEigen}` e `{RcppArmadillo}`",
      "description": "Como usar as bibliotecas C++ `Eigen` e `Armadillo` para poderosa Álgebra Linear\n",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "February 2, 2021",
      "contents": "\n\nContents\nArmadillo\nClasses do Armadillo\nComo usar Armadillo com {Rcpp} – {RcppArmadillo}\nComo usar Matrizes Esparsas no {RcppArmadillo}\n\nEigen\nClasses do Eigen\nComo usar Eigen com {Rcpp} – {RcppEigen}\nComo usar Matrizes Esparsas no {RcppEigen}\n\nBenchmarks\nExemplo – Multiplicação de Matrizes\nExemplo – Matriz Esparsa\nExemplo – Regressão Linear fast_lm()\n\nUsar {RcppArmadillo} ou {RcppEigen} no seu Pacote R\nAmbiente\n\n\n\nImagine Álgebra Linear. Adição, Multiplição de Matrizes. Sistemas de Equações Lineares. Inversões de Matrizes. Decomposições de Matrizes. Autovalores, Autovetores e Valores Singulares. Eu pessoalmente acredito que o inferno deve ser um lugar que as pessoas são obrigadas a fazer cálculos de álgebra linear na mão! POR TODA A ETERNIDADE!1.\nCaso você não saiba, o computador não foi criado para assistir pornografia para envio de e-mails, navegação na internet, ou games. Mas sim para operações e manipulações de matrizes! Shayle Searle no livro Matrix Algebra Useful for Statistics recorda que, durante seus anos de estudante de doutorado em 1959 na Cornell University, ele e seus colegas ficaram impressionados quando conseguiram inverter uma matriz de dimensão 10 x 10 em 7 minutos num computador. Searle também recorda que um ano antes, um colega inverteu uma matriz de dimensão 40 x 40 usando uma calculadora elétrica. Ele demorou 6 semanas!\nNesse tutorial vou mostrar como usar o básico das bibliotecas C++ Eigen e Armadillo. Ambas fazem a mesma coisa: Álgebra Linear e Manipulação de Matrizes e Vetores. Elas diferem (além da síntaxe) em uma coisa:\nArmadillo depende de LAPACK/BLAS/MKL\nEigen não possui nenhuma dependência\nAlém disso, em diversos benchmarks que eu fiz, Eigen (pelo menos no meu computador) é mais rápida que Armadillo. Esse tutorial apresentará primeiro Armadillo e a sua interface com R usando o {RcppArmadillo} e {Rcpp}. Na sequência apresentarei Eigen e sua interface com R usando o {RcppEigen} e {Rcpp}. Não se preocupe, qualquer uma das duas é literalmente “Álgebra Linear com Lasers”: são muito rápidas!\n\n\n\nFigure 1: Qualquer escolha entre Armadillo e Eigen são bem rápidas: Álgebra Linear com Lasers!.\n\n\n\nArmadillo\nArmadillo é uma biblioteca de álgebra linear de alta qualidade para a linguagem C++, visando um bom equilíbrio entre velocidade e facilidade de uso. Ela fornece sintaxe deliberadamente semelhante ao Matlab. Caso você tenha experiência prévia com Matlab, use Armadillo e seja feliz. Veja em seu site mais informações sobre a biblioteca Armadillo. Além disso, recomendo as seguintes referências sobre Armadillo:\nCheatsheet de síntaxe Armadillo vs Matlab / Octave feita pela própria equipe da Armadillo.\nSite do pacote {RcppArmadillo} que faz a interface entre Rcpp e Armadillo.\nCheatsheet de operações comuns de {RcppArmadillo} pelo James Balamuta (também conhecido como TheCoatlessProfessor).\nDocumentação do Armadillo\nClasses do Armadillo\nArmadillo possui algumas categorias de classes para representar diferentes objetos de álgebra linear:\nDense Matrix – Classes para matrizes densas (não-esparsas), com elementos armazenados em ordem de coluna principal (ou seja, coluna por coluna).\nmat      =    Mat<double>\ndmat     =    Mat<double>\nfmat     =    Mat<float>\ncx_mat   =    Mat<cx_double>  // cx_ é Complex Numbers\ncx_dmat  =    Mat<cx_double>  // cx_ é Complex Numbers\ncx_fmat  =    Mat<cx_float>   // cx_ é Complex Numbers\nDense Vector – aqui se divide em vetores coluna (Column Vector) e vetores linha (Row Vector).\nColumn Vector – Dense Matrix com apenas uma única coluna.\nvec      =  colvec       =  Col<double>\ndvec     =  dcolvec      =  Col<double>\nfvec     =  fcolvec      =  Col<float>\ncx_vec   =  cx_colvec    =  Col<cx_double>  // cx_ é Complex Numbers\ncx_dvec  =  cx_dcolvec   =  Col<cx_double>  // cx_ é Complex Numbers\ncx_fvec  =  cx_fcolvec   =  Col<cx_float>   // cx_ é Complex Numbers\nRow Vector – Dense Matrix com apenas uma única linha.\nrowvec       =   Row<double>\ndrowvec      =   Row<double>\nfrowvec      =   Row<float>\ncx_rowvec    =   Row<cx_double>  // cx_ é Complex Numbers\ncx_drowvec   =   Row<cx_double>  // cx_ é Complex Numbers\ncx_frowvec   =   Row<cx_float>   // cx_ é Complex Numbers\nSparse Matrix – Classes para matrizes esparsas; destina-se a armazenar matrizes muito grandes, onde a grande maioria dos elementos são zero.\nsp_mat      =   SpMat<double>\nsp_dmat     =   SpMat<double>\nsp_fmat     =   SpMat<float>\nsp_cx_mat   =   SpMat<cx_double>  // cx_ é Complex Numbers\nsp_cx_dmat  =   SpMat<cx_double>  // cx_ é Complex Numbers\nsp_cx_fmat  =   SpMat<cx_float>   // cx_ é Complex Numbers\nComo usar Armadillo com {Rcpp} – {RcppArmadillo}\nPrimeiro, certifique-se que você possui a biblioteca Armadillo instalada:\nLinux: sudo apt-get install make libopenblas-dev liblapack-dev libarpack2-dev libsuperlu-dev\nMacOS: brew install armadillo\nWindows: baixe no site do Armadillo\nSegundo, installe o pacote {RcppArmadillo} para R.\nTerceiro, coloque em todo código que deseja usar o Armadillo com {Rcpp} a seguinte síntaxe:\n#include <RcppArmadillo.h>\nusing namespace arma;\n\n// [[Rcpp::depends(RcppArmadillo)]]\nAtenção!: não usar o header do {Rcpp} (#include <Rcpp.h>), pois ele conflita com o header do {RcppArmadillo} (#include <RcppArmadillo.h>).\nPronto! É isso.\nComo usar Matrizes Esparsas no {RcppArmadillo}\nO R possui um pacote {Matrix} que dá suporte à matrizes esparsas com uma classe dgCMatrix que significa double sparse Compressed Matrix. Veja um exemplo abaixo de uma matriz densa com 1,000,000 de elementos. Vamos enfiar alguns zeros nela de maneira aleatória. A matriz densa possui um tamanho de 7,6mb.\n\n\nset.seed(123)\ndata <- rnorm(1e6)\nzero_index <- sample(1e6)[1:9e5]\ndata[zero_index] <- 0\nmat <- matrix(data, ncol=1000)\nmat[1:5,1:5]\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] 0.00    0    0    0    0\n[2,] 0.00    0    0    0    0\n[3,] 0.00    0    0    0    0\n[4,] 0.00    0    0    0    0\n[5,] 0.13    0    0    0    0\n\nprint(object.size(mat), units = \"auto\")\n\n\n7.6 Mb\n\nAgora a mesma matriz mas armazenada como uma matriz esparsa pelo pacote {Matrix}. Note que os zeros foram eliminados da matriz (são armazenados de uma outra maneira) e o seu tamanho agora é 1,1mb.\n\n\nlibrary(Matrix)\nmat_sparse <- Matrix(mat, sparse=TRUE)\nmat_sparse[1:5,1:5]\n\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n                 \n[1,] .    . . . .\n[2,] .    . . . .\n[3,] .    . . . .\n[4,] .    . . . .\n[5,] 0.13 . . . .\n\nprint(object.size(mat_sparse),units=\"auto\")\n\n\n1.1 Mb\n\nSe inspecionarmos de maneira detalhada um objeto dgCMatrix, vemos que temos três atributos importantes:\ni – vetor com o índice da linha de todos os elementos não-zero.\np – vetor com o índice da coluna de todos os elementos não-zero.\nx – vetor com os valores de todos os elementos não-zero.\n\n\nstr(mat_sparse)\n\n\nFormal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  ..@ i       : int [1:100000] 4 13 16 28 29 36 57 61 80 106 ...\n  ..@ p       : int [1:1001] 0 100 211 316 412 522 620 724 806 894 ...\n  ..@ Dim     : int [1:2] 1000 1000\n  ..@ Dimnames:List of 2\n  .. ..$ : NULL\n  .. ..$ : NULL\n  ..@ x       : num [1:100000] 0.129 0.111 0.498 -1.138 1.254 ...\n  ..@ factors : list()\n\nPara que {RcppArmadillo} nos retorne um objeto dgCMatrix, é simples: basta a função retornar um objeto arma::sp_mat. Este exemplo foi retirado da vinheta de Matriz Esparsa do {RcppArmadillo}.\n\n#include <RcppArmadillo.h>\nusing namespace Rcpp;\nusing namespace arma;\n\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// [[Rcpp::export]]\nsp_mat sqrt_arma(sp_mat& X) {\n  return sqrt(X);\n}\n\n\n\ni <- c(1,3:8)\np <- c(2,9,6:10)\nx <- 7 * (1:7)\nA <- sparseMatrix(i, p, x = x)\nsqrt_arma(A)\n\n\n8 x 10 sparse Matrix of class \"dgCMatrix\"\n                                  \n[1,] . 2.6 . . . .   .   .   .   .\n[2,] . .   . . . .   .   .   .   .\n[3,] . .   . . . .   .   .   3.7 .\n[4,] . .   . . . 4.6 .   .   .   .\n[5,] . .   . . . .   5.3 .   .   .\n[6,] . .   . . . .   .   5.9 .   .\n[7,] . .   . . . .   .   .   6.5 .\n[8,] . .   . . . .   .   .   .   7\n\nEigen\nEigen é uma biblioteca de C++ para álgebra linear: matrizes, vetores, solucionadores numéricos e algoritmos relacionados. Ela suporta matrizes densas e esparsas em números inteiros (int), de ponto flutuante (float e double) e complexos (complex), decomposições de matrizes e soluções de sistemas lineares. Seu desempenho em muitos algoritmos é comparável a algumas das melhores implementações baseadas em LAPACK e BLAS (exemplo Armadillo).\nEigen não tem nenhuma dependência externa, apenas da biblioteca padrão C++11 STL (que todo compilador C++ dá suporte). Além disso, Eigen usa o sistema de build CMake, mas apenas para construir a documentação e os testes de unidade, e para automatizar a instalação. Se você deseja apenas usar o Eigen, pode usar os arquivos header imediatamente. Não há biblioteca binária para vincular e nenhum arquivo header configurado. Eigen é uma biblioteca pura definida nos headers.\nPor conta dessa simplicidade, facilidade de instalação (virtualmente sem dependências) e alta compatibilidade, eu prefiro Eigen ao invés de Armadillo. Além disso, nos meus benchmarks quase sempre Eigen é mais rápida que Armadillo2.\nPara Eigen recomendo as seguintes referências (todas do site do Eigen):\nGetting Started\nReferência Rápida de Matrizes/Vetores Densos\nDocumentação das Decomposições e Soluções Lineares de Matrizes/Vetores Densos\nReferência Rápida de Matrizes/Vetores Esparsas\nCatálogo de Operações Matemáticas de Elementos de Matrizes/Vetores Densos\nClasses do Eigen\nNa mesma pegada do Armadillo, Eigen possui algumas categorias de classes para representar diferentes objetos de álgebra linear.\nA classe Matrix lida com matrizes e vetores densos, não-esparsos. E a classe SparseMatrix lida com matrizes e vetores esparsos. Matrizes densas e vetores são arranjos comuns de elementos. Todos os elementos são armazenados em uma matriz contígua comum. Isso é diferente de matrizes e vetores esparsos, onde os elementos são armazenados como uma lista de elementos diferentes de zero.\nEigen é muito mais simples: tudo é Matrix ou SparseMatrix/SparseVector. Matrix aceita três argumentos de template (o que vai entre <>):\ntipo de escalar (ex, double)\nnúmero de linhas (um int ou Eigen::Dynamic)\nnúmero de colunas (um int ou Eigen::Dynamic)\nSparseMatrix e SparseVector também aceitam três argumentos de template (o que vai entre <>):\ntipo de escalar (ex, double)\nlógica de armazenamento (ColMajor ou RowMajor, o default é ColMajor)\ntipo de índice interno (default é int).\nAlém disso Eigen tem uma síntaxe bem elegante para atalhos de matrizes. A lógica desses atalhos é a seguinte Classe-Numero_de_Elementos-Tipo_Escalar. Veja alguns exemplos abaixo:\n// Matrizes Densas - Tamanho Fixo\nMatrix<double, 3, 3> // Especificação Completa\nMatrix3d             // Atalho\n\n// Matrizes Densas - Tamanho Dinâmico\nMatrix<double, Dynamic, Dynamic> // Especificação Completa\nMatrixXd                         // Atalho\n\n// Matrizes Esparsas (Sem Atalhos e sem Fixo/Dinâmico)\nSparseMatrix<double>\n\n// Vetores em Eigen são apenas Matrizes 1-D\n// Vetores Densos - Tamanho Fixo\nMatrix<double, 3, 1> // Vetor Coluna - Especificação Completa\nMatrix<double, 1, 3> // Vetor Linha - Especificação Completa\nVector3d             // Vetor Coluna - Atalho\nRowVector3d          // Vetor Linha - Atalho\n\n// Vetores Densos - Tamanho Dinâmico\nMatrix<double, Dynamic, 1> // Vetor Coluna - Especificação Completa\nMatrix<double, 1, Dynamic> // Vetor Linha - Especificação Completa\nVectorXd                   // Vetor Coluna - Atalho\nRowVectorXd                // Vetor Linha - Atalho\n\n// Vetores Esparsas (Sem Atalhos e sem Fixo/Dinâmico)\nEigen::SparseVector<double>\n\n// Alguns exemplos extras para entender a lógica dos Atalhos\nMatrix<float,Dynamic,Dynamic>  =   MatrixXf\nMatrix<double,Dynamic,1>       =   VectorXd\nMatrix<int,1,Dynamic>          =   RowVectorXi\nMatrix<float,3,3>              =   Matrix3f\nMatrix<float,4,1>              =   Vector4f\nTamanho Fixo vs Dinâmico\nInternamente, uma matriz Eigen de tamanho fixo é apenas um array simples de C++ alocada na pilha (stack) e tem custo zero de tempo de execução. Em contraste, o array C++ de uma matriz Eigen de tamanho dinâmico é sempre alocada na heap e armazena seu número de linhas e colunas como variáveis de membro (member variables).\nPara tamanhos grandes o suficiente, digamos, para tamanhos maiores que (aproximadamente) 32, o benefício de desempenho de usar tamanhos fixos torna-se insignificante. Pior, tentar criar uma matriz muito grande usando tamanhos fixos dentro de uma função pode resultar em um stack overflow, já que Eigen tentará alocar o array automaticamente como uma variável local, e isso normalmente é feito na pilha (stack). Finalmente, dependendo das circunstâncias, Eigen também pode ser mais agressivo tentando vetorizar (usar instruções SIMD) quando tamanhos dinâmicos são usados.\nMeu conselho: use sempre matrizes e vetores de tamanho dinâmico e seja feliz sabendo que na maioria das vezes eles serão mais rápidos que os de tamanho fixo.\nAcessando e Modificando Elementos\nO principal meio de acessar elementos e modificar do Eigen é pelo operador (). Para matrizes use dois índices (linha, coluna) e para vetores apenas use um índice (índice). Geralmente m é uma matriz e v é um vetor.\nm(0,0) = 3;\nv(0)   = 4;\nFatiando (Slice) Matrizes e Vetores\nTem várias maneiras de fatiar (slice) matrizes e vetores. Veja alguns exemplos:\n// Vetores\nv.head(n)\nv.tail(n)\nv.segment(pos,n)\n\n// Matriz\nm.block(i,j,rows,cols)\n\n// Matriz - Cantos (Corners)\nm.topLeftCorner(rows,cols) \nm.topRightCorner(rows,cols)\nm.bottomLeftCorner(rows,cols)\nm.bottomRightCorner(rows,cols)\nm.topRows(rows)\nm.bottomRows(rows)\nm.leftCols(cols)\nm.rightCols(cols)\nInicializando Matrizes e Vetores\nPor padrão os elementos de uma matriz não são inicializados na sua criação. Há algumas maneiras de inicializar os elementos de uma matriz ou vetor em Eigen:\nInicialização usando a vírgula (Comma Initialization)\nMatrix3f m;  // pode ser também MatrixXd\n\nm << 1, 2, 3,\n     4, 5, 6,\n     7, 8, 9;\nMatrizes especiais. Existem alguns métodos estáticos para todas as classes Matrix. Eles são apenas para tamanhos fixos.\n// Matriz com Zeros\nMatrix2d::Zero()\n\n// Matrizes Aleatórias\nMatrix2i::Random()\n\n// Matriz Identidade\nMatrix3d::Identity()\n\n// Vetores Espaçados Linearmente (size, low, high)\n// tipo um seq() do R\nVectorXf v;\nv.setLinSpaced(5,0.5f,1.5f);\nTamanho e Dimensões\nO tamanho atual de uma matriz pode ser recuperado por .rows(), .cols() e .size(). Esses métodos retornam o número de linhas, o número de colunas e o número de elementos, respectivamente. O redimensionamento de uma matriz de tamanho dinâmico é feito pelo método .resize().\nm.cols();\nm.rows();\nm.resize(4,4);\nOperações Aritméticas com Matrizes e Vetores\nTodos os vetores e matrizes de Eigen aceitam adição, subtração, multiplicação, divisão: +,-, *, /. Além disso, tem MUITAS outras operações e decomposições que podem ser feitas. Não vou listar todas aqui, consulte a documentação do Eigen.\nComo usar Eigen com {Rcpp} – {RcppEigen}\nPrimeiro, certifique-se que você possui a biblioteca Eigen instalada:\nLinux: sudo apt install libeigen3-dev\nMacOS: brew install eigen\nWindows: baixe no site do Eigen\nSegundo, installe o pacote {RcppEigen} para R.\nTerceiro, coloque em todo código que deseja usar o Eigen com {Rcpp} a seguinte síntaxe:\n#include <RcppEigen.h>\nusing namespace Eigen;\n\n// [[Rcpp::depends(RcppEigen)]]\nAtenção!: não usar o header do {Rcpp} (#include <Rcpp.h>), pois ele conflita com o header do {RcppEigen} (#include <RcppEigen.h>).\nPronto! É isso.\nConversões do {RcppEigen}\nO {RcppEigen} automaticamente converterá os tipos de retorno das funções na seguinte lógica:\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#bwlmvbnigf .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#bwlmvbnigf .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 4px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#bwlmvbnigf .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#bwlmvbnigf .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#bwlmvbnigf .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#bwlmvbnigf .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#bwlmvbnigf .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#bwlmvbnigf .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#bwlmvbnigf .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#bwlmvbnigf .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#bwlmvbnigf .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#bwlmvbnigf .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#bwlmvbnigf .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#bwlmvbnigf .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bwlmvbnigf .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#bwlmvbnigf .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#bwlmvbnigf .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#bwlmvbnigf .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#bwlmvbnigf .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#bwlmvbnigf .gt_left {\n  text-align: left;\n}\n\n#bwlmvbnigf .gt_center {\n  text-align: center;\n}\n\n#bwlmvbnigf .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#bwlmvbnigf .gt_font_normal {\n  font-weight: normal;\n}\n\n#bwlmvbnigf .gt_font_bold {\n  font-weight: bold;\n}\n\n#bwlmvbnigf .gt_font_italic {\n  font-style: italic;\n}\n\n#bwlmvbnigf .gt_super {\n  font-size: 65%;\n}\n\n#bwlmvbnigf .gt_footnote_marks {\n  font-style: italic;\n  font-size: 65%;\n}\nTipo de Objeto R\n      Classe Eigen\n    numeric matrix\n\n      MatrixXd\n\n    integer matrix\n\n      MatrixXi\n\n    complex matrix\n\n      MatrixXcd\n\n    numeric vector\n\n      VectorXd\n\n    integer vector\n\n      VectorXi\n\n    complex vector\n\n      VectorXcd\n\n    Matrix::dgCMatrix\n\n      SparseMatrix<double>\n\n    \n\nComo usar Matrizes Esparsas no {RcppEigen}\nPara que {RcppEigen} nos retorne um objeto dgCMatrix, é simples: basta a função retornar um objeto Eigen::SparseMatrix<double>. Vou usar o mesmo exemplo de operação com matriz esparsa do {RcppArmadillo}:\n\n#include <RcppEigen.h>\nusing namespace Rcpp;\nusing namespace Eigen;\n\n// [[Rcpp::depends(RcppEigen)]]\n\n// [[Rcpp::export]]\nSparseMatrix<double> sqrt_eigen(SparseMatrix<double>& X) {\n  return X.cwiseSqrt();\n}\n\n\n\ni <- c(1,3:8)\np <- c(2,9,6:10)\nx <- 7 * (1:7)\nA <- sparseMatrix(i, p, x = x)\nsqrt_eigen(A)\n\n\n8 x 10 sparse Matrix of class \"dgCMatrix\"\n                                  \n[1,] . 2.6 . . . .   .   .   .   .\n[2,] . .   . . . .   .   .   .   .\n[3,] . .   . . . .   .   .   3.7 .\n[4,] . .   . . . 4.6 .   .   .   .\n[5,] . .   . . . .   5.3 .   .   .\n[6,] . .   . . . .   .   5.9 .   .\n[7,] . .   . . . .   .   .   6.5 .\n[8,] . .   . . . .   .   .   .   7\n\nBenchmarks\nEstá na hora de mais uma vez colocarmos o que vimos em prática. Além disso fazer alguns benchmarks de Eigen vs Armadillo.\nExemplo – Multiplicação de Matrizes\nNesse caso vamos comparar multiplicar duas matrizes em C++ usando o {Rcpp}, {RcppArmadillo} e {RcppEigen}\n\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector mat_mul(const NumericVector& A, const NumericVector& B) {\n  NumericVector C = A * B;\n  \n  // dimensões para Vector virar Matrix no R\n  int dim = sqrt(A.length());\n  C.attr(\"dim\") = Dimension(dim, dim);\n  \n  return C;\n}\n\n\n#include <RcppArmadillo.h>\nusing namespace Rcpp;\nusing namespace arma;\n\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// [[Rcpp::export]]\nmat mat_mul_arma(const mat& A, const mat& B) {\n  return A * B;\n}\n\n\n#include <RcppEigen.h>\nusing namespace Rcpp;\nusing namespace Eigen;\n\n// [[Rcpp::depends(RcppEigen)]]\n\n// [[Rcpp::export]]\nMatrixXd mat_mul_eigen(const MatrixXd& A, const MatrixXd& B){\n  return A * B;\n}\n\n\n\nn <- 10^3\nX <- matrix(rnorm(n * n), nrow = n)\n\nbench::mark(\n  Rcpp = mat_mul(X, X),\n  arma = mat_mul_arma(X, X),\n  eigen = mat_mul_eigen(X, X),\n  check = FALSE\n)\n\n\n# A tibble: 3 x 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Rcpp         1.12ms   1.18ms    735.      7.63MB     131.\n2 arma       635.28ms 635.28ms      1.57    7.63MB       0 \n3 eigen       145.2ms 153.66ms      6.54    7.63MB       0 \n\nNo meu computador {RcppEigen} é mais rápido que {RcppArmadillo}, mas ambos são mais lentos que uma implementação simples com {Rcpp}.\nExemplo – Matriz Esparsa\nVamos usar mat_sparse criada que possui dimensão 1.000 x 1.000 e tomar a raiz quadrada de todos os elementos.\n\n\nbench::mark(\n  arma = sqrt_eigen(mat_sparse),\n  eigen = sqrt_eigen(mat_sparse)\n)\n\n\n# A tibble: 2 x 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 arma         1.07ms   1.17ms      794.    1.16MB     17.7\n2 eigen        1.08ms   1.16ms      843.    1.15MB     22.6\n\nNovamente Eigen é um pouco mais rápida que Armadillo, mas a diferença é pequena.\nExemplo – Regressão Linear fast_lm()\nEsse exemplo, originalmente do criador dos pacotes do ecossistema {Rcpp} Dirk Eddelbuettel na vinheta introdutória do {Rcpp}, é bem interessante. Aqui vamos aplicar uma regressão linear tanto em Armadillo quando em Eigen. Ambos usam o solve() que é um solucionador de sistemas de equações lineares3.\n\n#include <RcppArmadillo.h>\nusing namespace arma;\n\n// [[Rcpp::depends(RcppArmadillo)]]\n\n// [[Rcpp::export]]\nRcpp::List fast_lm_arma(const vec& y, const mat& X) {\n\n  int n = X.n_rows, k = X.n_cols;\n  \n  colvec coef  = solve(X, y); \n  colvec resid = y - X*coef; \n  \n  double sig2 = as_scalar(trans(resid)*resid/(n-k));\n  colvec stderrest = sqrt(sig2 * diagvec(inv(trans(X)*X)));\n  \n  return Rcpp::List::create(Rcpp::Named(\"coefficients\") = coef,\n                            Rcpp::Named(\"stderr\")       = stderrest);\n}\n\n\n#include <RcppEigen.h>\nusing namespace Eigen;\n\n// [[Rcpp::depends(RcppEigen)]]\n\n// [[Rcpp::export]]\nRcpp::List fast_lm_eigen(const VectorXd& y, const MatrixXd& X) {\n\n  int n = X.rows(), k = X.cols();\n    \n    // Usando SVD Decomposition\n    //VectorXd coef = X.bdcSvd(ComputeThinU | ComputeThinV).solve(y);\n\n    // Usando QR Decomposition\n    //VectorXd coef = X.colPivHouseholderQr().solve(y);\n\n    // Usando Normal Equations com LDL Decomposition (mais rápida)\n    VectorXd coef = (X.transpose() * X).ldlt().solve(X.transpose() * y);\n    \n    VectorXd resid = y - X*coef;\n\n    double sig2 = resid.squaredNorm() / (n - k);\n \n  VectorXd stderrest = (sig2 * ((X.transpose() * X).inverse()).diagonal()).array().cwiseSqrt();\n    \n    return Rcpp::List::create(Rcpp::Named(\"coefficients\") = coef,\n                            Rcpp::Named(\"stderr\")       = stderrest);\n}\n\n\n\ny <- log(trees$Volume)\nX <- cbind(1, log(trees$Girth))\nbench::mark(\n  R = lm(y ~ X),\n  arma = fast_lm_arma(y, X),\n  eigen = fast_lm_eigen(y, X),\n  check = FALSE\n)\n\n\n# A tibble: 3 x 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 R          461.06µs 491.65µs     1932.  476.36KB     4.08\n2 arma         5.57µs    6.1µs   146428.    2.49KB     0   \n3 eigen        5.11µs   6.81µs   150070.    2.49KB     0   \n\nTanto Eigen quanto Armadillo são rápidos! Quase 100x mais rápidos. Novamente a diferença entre Eigen e Armadillo é pequena.\nUsar {RcppArmadillo} ou {RcppEigen} no seu Pacote R\nEu recomendo usar o pacote {usethis} e seguir as instruções.\nusethis::use_rcpp_armadillo()\nusethis::use_rcpp_eigen()\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.3 (2020-10-10)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] Matrix_1.3-2   magrittr_2.0.1 dplyr_1.0.2    gt_0.2.2      \n[5] Rcpp_1.0.5    \n\nloaded via a namespace (and not attached):\n [1] RcppEigen_0.3.3.9.1      tidyselect_1.1.0        \n [3] xfun_0.20                purrr_0.3.4             \n [5] lattice_0.20-41          colorspace_2.0-0        \n [7] vctrs_0.3.6              generics_0.1.0          \n [9] htmltools_0.5.0          emo_0.0.0.9000          \n[11] yaml_2.2.1               utf8_1.1.4              \n[13] rlang_0.4.10             pillar_1.4.7            \n[15] glue_1.4.2               jpeg_0.1-8.1            \n[17] lifecycle_0.2.0          stringr_1.4.0           \n[19] munsell_0.5.0            commonmark_1.7          \n[21] gtable_0.3.0             bench_1.1.1             \n[23] evaluate_0.14            RcppArmadillo_0.10.1.2.0\n[25] knitr_1.30               parallel_4.0.3          \n[27] fansi_0.4.1              profmem_0.6.0           \n[29] highr_0.8                scales_1.1.1            \n[31] backports_1.2.1          checkmate_2.0.0         \n[33] jsonlite_1.7.2           distill_1.1             \n[35] ggplot2_3.3.3            png_0.1-7               \n[37] digest_0.6.27            stringi_1.5.3           \n[39] bookdown_0.21            grid_4.0.3              \n[41] rprojroot_2.0.2          BH_1.72.0-3             \n[43] cli_2.2.0                tools_4.0.3             \n[45] sass_0.2.0               tibble_3.0.4            \n[47] crayon_1.3.4             pkgconfig_2.0.3         \n[49] downlit_0.2.1            ellipsis_0.3.1          \n[51] lubridate_1.7.9.2        assertthat_0.2.1        \n[53] rmarkdown_2.6            rstudioapi_0.13         \n[55] R6_2.5.0                 compiler_4.0.3          \n\n\napesar de eu achar Álgebra Linear fascinante e ter trocado alguns e-mails com Gilbert Strang.↩︎\nquando não é porque eu fiz alguma besteira não eficiente em Eigen e quando corrijo fica mais rápida.↩︎\npor debaixo dos panos há uma inversão otimizada de matriz.↩︎\n",
      "last_modified": "2021-01-10T07:44:35-03:00"
    },
    {
      "path": "4-RcppParallel.html",
      "title": "Paralelização -- `{RcppParallel}`",
      "description": "Como fazer seu código Rcpp ser ainda mais rápido\n",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "February 2, 2021",
      "contents": "\n\nContents\nC++ em Paralelo – Biblioteca Intel TBB\nComo usar {Rcpp} em paralelo – {RcppParallel}\nComo usar {RcppParallel}\nQuantos Threads?\nparallelFor – Paralelizando Loops for\nparallelReduce – Paralelizando operações Reduce\n\nUsar {RcppParallel} no seu Pacote R\nAmbiente\n\n\n\nVimos que o {Rcpp} faz o seu código R ficar muito mais rápido. Tudo o que mostramos até agora foi usando apenas um único core/processador (single thread) do computador1. Agora imaginem o quão rápido seu código R pode ficar se você conseguir rodar {Rcpp} em paralelo 🤯!\n\n\n\nFigure 1: Código {Rcpp} rodando em paralelo: muito rápido!\n\n\n\nC++ em Paralelo – Biblioteca Intel TBB\nO Pacote {RcppParallel} usa a biblioteca TBB da Intel. TBB (Threading Building Blocks) é uma biblioteca de C++ desenvolvida pela Intel para programação paralela em processadores multi-core. Usando TBB, um cálculo é dividido em tarefas que podem ser executadas em paralelo. A biblioteca gerencia e agenda threads para executar essas tarefas.\nComo usar {Rcpp} em paralelo – {RcppParallel}\nPrimeiro, certifique-se que você possui a biblioteca TBB da Intel instalada:\nLinux: sudo apt install libtbb-dev\nMacOS: brew install tbb\nWindows: baixe no site da Intel\nSegundo, installe o pacote {RcppParallel} para R.\nTerceiro, coloque em todo código que deseja paralelizar com {RcppParallel} a seguinte síntaxe:\n#include <Rcpp.h>\n#include <RcppParallel.h>\nusing namespace Rcpp;\nusing namespace RcppParallel;\n\n//[[Rcpp::depends(RcppParallel)]]\nPronto! É isso.\nComo usar {RcppParallel}\nÉ possível implementar paralelização em diversas partes do seu código {Rcpp} com o {RcppParallel}. Aqui eu vou cobrir apenas os dois algoritmos paralelos do {RcppParallel}2:\nparallelFor: Este aqui é fácil de explicar. Qualquer loop for do seu código pode ser um bom candidato à paralelização.\nparallelReduce: Reduce é um algoritmo bem conhecido em ciências da computação. Reduce aplica um operação binária (como adição) em uma sequência definida de elementos, resultando em um único valor. O exemplo sum_of_squares do tutorial 2. Como incorporar C++ no R - {Rcpp} é uma aplicação de um Reduce3. Toda vez que você tiver essa situação você pode paralelizar com parallelReduce.\nAmbos os algortimos usam o struct Worker definido no código do {RcppParallel} que é uma interface para a biblioteca TBB.\nAlém disso {RcppParallel} usa duas classes, uma para vetores e outra para matrizes:\nRVector<T> – onde T é o tipo de variável (double, int etc.)\nRMatrix<T> – onde T é o tipo de variável (double, int etc.)\nQuantos Threads?\nAo carregar o {RcppParallel} é importante você designar o número de threads/cores que deseja que o código {RcppParallel} use para paralelização. Caso queira usar todos os seus threads/cores disponíveis, coloque como argumento parallel::detectCores() que retorna um número inteiro com todos os threads/cores disponíveis no seu computador. Aqui estou usando todos os threads/cores disponíveis: 12 threads/cores.\nSe não especificado, por padrão {RcppParallel} usa todos os threads/cores disponíveis.\n\n\nlibrary(Rcpp)\nlibrary(RcppParallel)\nsetThreadOptions(parallel::detectCores())\nprint(parallel::detectCores())\n\n\n[1] 12\n\nparallelFor – Paralelizando Loops for\nPara usar o parallelFor você deve criar um objeto Worker e definir um operador operator() desse objeto que será invocado pelo {RcppParallel} e roda em paralelo. Isso cria uma função com com o nome do objeto Worker que você criou4. Essa função toma como argumento um intervalo [começo, fim) e lida com todas as questões de segurança e travas de threads que são um porre bem complicadas de maneira automática. Note que o elemento fim do intervalo não é incluído no intervalo (mesmo padrão de comportamento dos iteradores end da biblioteca padrão C++11 STL).\nPara mais detalhes, consulte a documentação do parallelFor no site do {RcppParallel}.\nExemplo parallelFor – Raiz Quadrada de Elementos da Matriz.\nAqui vou usar o exemplo da documentação do parallelFor no site do {RcppParallel} de uma função paralela que cacula a raiz quadrada dos elementos de uma matriz. Adicionei alguns comentários para você entender o que está sendo feito. Além disso, há uma versão single-thread também que vamos testar desempenho.\n\n#include <Rcpp.h>\n#include <RcppParallel.h>\n#include <algorithm>\n\nusing namespace Rcpp;\nusing namespace RcppParallel;\n\n// [[Rcpp::depends(RcppParallel)]]\n\n// Criando um objeto Worker chamado SquareRoot\nstruct SquareRoot : public Worker\n{\n   // Variáveis Membro públicas\n   const RMatrix<double> input;\n   RMatrix<double> output;\n   \n   // Construtor do Objeto Worker SquareRoot\n   SquareRoot(const Rcpp::NumericMatrix input, Rcpp::NumericMatrix output) \n      : input(input), output(output) {}\n   \n   // Overload do operador ()\n   void operator()(std::size_t begin, std::size_t end) {\n      std::transform(input.begin() + begin, \n                     input.begin() + end, \n                     output.begin() + begin, \n                     ::sqrt);\n   }\n};\n\n// Função que chama o Objeto Worker SquareRoot\n// [[Rcpp::export]]\nNumericMatrix parallelMatrixSqrt(NumericMatrix x) {\n  \n  // Variável local output inicializada\n  NumericMatrix output(x.nrow(), x.ncol());\n  \n  // Invocação do operador() do Objeto Worker SquareRoot\n  SquareRoot squareRoot(x, output);\n  \n  // Paralelização do loop for\n  parallelFor(0, x.length(), squareRoot);\n  \n  return output;\n}\n\n// Versão single-thread\n// [[Rcpp::export]]\nNumericMatrix matrixSqrt(NumericMatrix orig) {\n  NumericMatrix mat(orig.nrow(), orig.ncol());\n  std::transform(orig.begin(), orig.end(), mat.begin(), ::sqrt);\n  return mat;\n}\n\n\n\nn <- 10^3\nX <- matrix(rnorm(n * n), nrow = n)\n\nbench::mark(\n  Rcpp = matrixSqrt(X),\n  RcppParallel = parallelMatrixSqrt(X),\n  check = FALSE\n)\n\n\n# A tibble: 2 x 6\n  expression        min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Rcpp           8.75ms   9.04ms      107.    7.63MB     36.6\n2 RcppParallel   3.19ms   3.33ms      300.    7.63MB     75.8\n\nUm ganho de 3x em paralelização para uma matriz de dimensão 1.000 x 1.000!\nparallelReduce – Paralelizando operações Reduce\nReduce é um algoritmo bem conhecido em ciências da computação. Reduce aplica um operação binária (como adição) em uma sequência definida de elementos, resultando em um único valor. O exemplo sum_of_squares do tutorial 2. Como incorporar C++ no R - {Rcpp} é uma aplicação de um Reduce5. Toda vez que você tiver essa situação você pode paralelizar com parallelReduce.\nA lógica do parallelReduce é similar ao parallelFor. Primeiro ambos usam objetos Worker, com algumas diferenças:\nAqui você precisa de dois construtores no seu Worker: um padrão e um “divisor”. O construtor padrão pega os dados de entrada e inicializa qualquer valor que está sendo acumulado (por exemplo, inicializar uma soma para zero). O construtor de divisão é chamado quando o trabalho precisa ser dividido em outros threads - ele toma uma referência à instância da qual está sendo dividido e simplesmente copia o ponteiro para os dados de entrada e inicializa seu valor “acumulado” para zero.\nUm operador operator() que executa o trabalho. Isso funciona da mesma forma que o operador operator() em parallelFor, mas em vez de gravar em outro vetor ou matriz, ele normalmente acumula um valor.\nUm método de junção que compõe as operações de duas instâncias de trabalho que foram divididas anteriormente. Aqui, simplesmente combinamos o valor acumulado da instância à qual estamos sendo associados ao nosso.\nPara mais detalhes, consulte a documentação do parallelReduce no site do {RcppParallel}\nExemplo parallelReduce – Soma dos Quadrados\nVamos reutilizar o exemplo sum_of_squares do tutorial 2. Como incorporar C++ no R - {Rcpp}.\nSoma dos quadrados é algo que ocorre bastante em computação científica, especialmente quando estamos falando de regressão, mínimos quadrados, ANOVA etc. Vamos paralelizar a implementação ingênua que fizemos no tutorial 2. Como incorporar C++ no R - {Rcpp} com dois loops for. Lembrando que esta implementação será uma função que aceita como parâmetro um vetor de números reais (C++ double / R numeric) e computa a soma de todos os elementos do vetor elevados ao quadrado.\nNovamente vou incluir comentários para o entendimento do que estamos fazendo no {RcppParallel}. Além disso, há uma versão single-thread também que vamos testar desempenho.\n\n#include <Rcpp.h>\n#include <RcppParallel.h>\n#include <algorithm>\nusing namespace RcppParallel;\nusing namespace Rcpp;\n\n// [[Rcpp::depends(RcppParallel)]]\n\n// [[Rcpp::plugins(\"cpp11\")]]\n// [[Rcpp::plugins(\"cpp2a\")]]\n\n// Criando um objeto Worker chamado sum_of_squares\nstruct sum_of_squares : public Worker\n{\n  // Variáveis Membro públicas\n  const RVector<double> input;\n  double value;\n  \n  // Construtor padrão do Objeto Worker\n  sum_of_squares(const NumericVector input) : input(input), value(0) {}\n  \n  // Construtor \"divisor\"\n  sum_of_squares(const sum_of_squares& sum, Split) : input(sum.input), value(0) {}\n  \n  // Overload do operador ()\n  void operator()(std::size_t begin, std::size_t end) {\n      value += std::accumulate(input.begin() + begin,\n                               input.begin() + end,\n                               0.0,\n                               [] (auto i, auto j) {return i + (j * j);});\n   }\n  \n  void join(const sum_of_squares& rhs) { \n      value += rhs.value; \n   }\n};\n\n// Função que chama o Objeto Worker sum_of_squares\n// [[Rcpp::export]]\ndouble parallel_sum_of_squares(NumericVector x) {\n   // variável local inicializada\n   sum_of_squares sum(x);\n   \n   // Paralelização do Reduce\n   parallelReduce(0, x.length(), sum);\n   \n   return sum.value;\n}\n\n// Versão single-thread\n// [[Rcpp::export]]\ndouble sum_of_squares(NumericVector x) {\n   return std::accumulate(x.begin(),\n                          x.end(),\n                          0.0,\n                          [] (auto i, auto j) {return i + (j * j);});\n}\n\n\n\nset.seed(123)\nn <- 1e6\nv <- rnorm(n)\nbench::mark(\n  Rcpp = sum_of_squares(v),\n  RcppParallel = parallel_sum_of_squares(v),\n  check = FALSE,\n)\n\n\n# A tibble: 2 x 6\n  expression        min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 Rcpp            899µs    922µs     1080.    2.49KB        0\n2 RcppParallel    100µs    120µs     8310.    2.49KB        0\n\nMais um sucesso! Ganho de 9x 🤯 para um vetor com 1.000.000 elementos!\nUsar {RcppParallel} no seu Pacote R\nAs instruções abaixo foram retiradas da documentação do {RcppParallel}.\nSe você deseja usar {RcppParallel} de dentro de um pacote R, você precisa editar vários arquivos para criar os links de construção e tempo de execução necessários. As seguintes adições devem ser feitas:\nNo DESCRIPTION:\nImports: RcppParallel\nLinkingTo: RcppParallel\nSystemRequirements: GNU make\nNo NAMESPACE:\nimportFrom(RcppParallel, RcppParallelLibs)\nNo src\\Makevars:\nCXX_STD = CXX11\nPKG_LIBS += $(shell ${R_HOME}/bin/Rscript -e \"RcppParallel::RcppParallelLibs()\")\nNo src\\Makevars.win:\nCXX_STD = CXX11\nPKG_CXXFLAGS += -DRCPP_PARALLEL_USE_TBB=1\n\nPKG_LIBS += $(shell \"${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe\" \\\n              -e \"RcppParallel::RcppParallelLibs()\")\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.3 (2020-10-10)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.10\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] RcppParallel_5.0.2 Rcpp_1.0.5        \n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.13   knitr_1.30        magrittr_2.0.1   \n [4] downlit_0.2.1     rlang_0.4.10      fansi_0.4.1      \n [7] stringr_1.4.0     highr_0.8         tools_4.0.3      \n[10] parallel_4.0.3    xfun_0.20         utf8_1.1.4       \n[13] cli_2.2.0         ellipsis_0.3.1    htmltools_0.5.0  \n[16] yaml_2.2.1        assertthat_0.2.1  digest_0.6.27    \n[19] lifecycle_0.2.0   tibble_3.0.4      crayon_1.3.4     \n[22] purrr_0.3.4       vctrs_0.3.6       distill_1.1      \n[25] glue_1.4.2        evaluate_0.14     rmarkdown_2.6    \n[28] emo_0.0.0.9000    bench_1.1.1       stringi_1.5.3    \n[31] pillar_1.4.7      compiler_4.0.3    generics_0.1.0   \n[34] profmem_0.6.0     lubridate_1.7.9.2 pkgconfig_2.0.3  \n\n\ntecnicamente, Eigen e Armadillo podem, dependendo da configuração do sistema operacional, automaticamente se beneficiar de paralelizações usando o OpenMP.↩︎\na biblioteca TBB tem muito mais algoritmos complexos caso necessario. Recomendo você olhar este link da documentação do {RcppParallel}.↩︎\ntecnicamente é um MapReduce.↩︎\nmais questões técnicas: quando você define um operador operator() de um objeto em C++ você dá um overload no operador parenthesis do objeto e o resultado é uma síntaxe similar à uma função com o nome do objeto.↩︎\ntecnicamente é um MapReduce.↩︎\n",
      "last_modified": "2021-01-10T09:05:29-03:00"
    },
    {
      "path": "5-cpp11.html",
      "title": "About this site",
      "description": "Some additional details about the website\n",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "February 2, 2021",
      "contents": "\n\nContents\nAmbiente\n\n\n\nAmbiente\n\n\nsessionInfo()\n\n\nR version 4.0.3 (2020-10-10)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRblas.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] Matrix_1.3-2   magrittr_2.0.1 dplyr_1.0.2    gt_0.2.2      \n[5] Rcpp_1.0.5    \n\nloaded via a namespace (and not attached):\n [1] RcppEigen_0.3.3.9.1      tidyselect_1.1.0        \n [3] xfun_0.20                purrr_0.3.4             \n [5] lattice_0.20-41          colorspace_2.0-0        \n [7] vctrs_0.3.6              generics_0.1.0          \n [9] htmltools_0.5.0          emo_0.0.0.9000          \n[11] yaml_2.2.1               utf8_1.1.4              \n[13] rlang_0.4.10             pillar_1.4.7            \n[15] glue_1.4.2               jpeg_0.1-8.1            \n[17] lifecycle_0.2.0          stringr_1.4.0           \n[19] munsell_0.5.0            commonmark_1.7          \n[21] gtable_0.3.0             bench_1.1.1             \n[23] evaluate_0.14            RcppArmadillo_0.10.1.2.0\n[25] knitr_1.30               parallel_4.0.3          \n[27] fansi_0.4.1              profmem_0.6.0           \n[29] highr_0.8                scales_1.1.1            \n[31] backports_1.2.1          checkmate_2.0.0         \n[33] jsonlite_1.7.2           distill_1.1             \n[35] ggplot2_3.3.3            png_0.1-7               \n[37] digest_0.6.27            stringi_1.5.3           \n[39] bookdown_0.21            grid_4.0.3              \n[41] rprojroot_2.0.2          BH_1.72.0-3             \n[43] cli_2.2.0                tools_4.0.3             \n[45] sass_0.2.0               tibble_3.0.4            \n[47] crayon_1.3.4             pkgconfig_2.0.3         \n[49] downlit_0.2.1            ellipsis_0.3.1          \n[51] lubridate_1.7.9.2        assertthat_0.2.1        \n[53] rmarkdown_2.6            rstudioapi_0.13         \n[55] R6_2.5.0                 compiler_4.0.3          \n\n\n\n\n",
      "last_modified": "2021-01-10T07:44:35-03:00"
    },
    {
      "path": "index.html",
      "title": "Rcpp - A interface entre R e C++",
      "description": "Como fazer seu código R ficar mais rápido com Rcpp\n",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "February 2, 2021",
      "contents": "\n\nContents\nÍndice\nComo Configurar um Ambiente para {Rcpp}\nPacotes do ecossistema R + C++\nLicença\n\n\n\n\nOk, você quer fazer o seu código R rodar mais rápido? Já pensou em colocar partes do seu código em C++?\n\n\n\nFigure 1: R com C++ sem dúvida bate a marca dos 12 parsecs\n\n\n\nÍndice\nPor que C++? R não é suficiente?\nComo incorporar C++ no R – {Rcpp}\nManipulação de Matrizes – {RcppEigen} e {RcppArmadillo}\nParalelização – {RcppParallel}\n{cpp11} – Nova Interface do pessoal do RStudio\nComo Configurar um Ambiente para {Rcpp}\nClaro, que primeiro você deve instalar o R pelo CRAN.\nLinux: Instale a versão desenvolvedor do R com sudo apt-get install r-base-dev ou similar\nMacOS: Instale o Xcode da App Store e execute o comando xcode-select --install para instalar o Xcode Command Line Tools\nWindows: Instale o Rtools\nPacotes do ecossistema R + C++\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#hzkdqzmtki .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#hzkdqzmtki .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 4px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#hzkdqzmtki .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#hzkdqzmtki .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#hzkdqzmtki .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#hzkdqzmtki .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#hzkdqzmtki .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#hzkdqzmtki .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#hzkdqzmtki .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#hzkdqzmtki .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#hzkdqzmtki .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#hzkdqzmtki .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#hzkdqzmtki .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#hzkdqzmtki .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hzkdqzmtki .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hzkdqzmtki .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#hzkdqzmtki .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#hzkdqzmtki .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#hzkdqzmtki .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#hzkdqzmtki .gt_left {\n  text-align: left;\n}\n\n#hzkdqzmtki .gt_center {\n  text-align: center;\n}\n\n#hzkdqzmtki .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#hzkdqzmtki .gt_font_normal {\n  font-weight: normal;\n}\n\n#hzkdqzmtki .gt_font_bold {\n  font-weight: bold;\n}\n\n#hzkdqzmtki .gt_font_italic {\n  font-style: italic;\n}\n\n#hzkdqzmtki .gt_super {\n  font-size: 65%;\n}\n\n#hzkdqzmtki .gt_footnote_marks {\n  font-style: italic;\n  font-size: 65%;\n}\nTotal de Downloads do CRAN\n    \n    Pacote\n      Total de Downloads1\n      Links Reversos2,3\n    Rcpp\n\n      41,39M\n      2.312\n    BH\n\n      23,34M\n      259\n    RcppArmadillo\n\n      13,27M\n      846\n    RcppEigen\n\n      10,95M\n      286\n    cpp11\n\n      3,74M\n      9\n    RcppParallel\n\n      2,14M\n      82\n    \n        \n          1\n          \n           \n          Downloads entre 01/01/2016 e 31/12/2020.\n          \n        \n          2\n          \n           \n          Link reverso ocorre quando um pacote depende do código em C/C++ de outro.\n          \n        \n          3\n          \n           \n          Total em 10/01/2021.\n          \n      \n    \n\nLicença\nEste obra está licenciado com uma Licença Creative Commons Atribuição-CompartilhaIgual 4.0 Internacional.\n\n\n\n\n",
      "last_modified": "2021-01-10T07:44:35-03:00"
    },
    {
      "path": "Tutorial_Rcpp.html",
      "author": [],
      "contents": "\nRcppParallel – Paralelização Exemplo usando sum_of_squares_rcpp()\ncpp11 – Nova Interface do pessoal do RStudio https://cran.r-project.org/web/packages/cpp11/vignettes/converting.html\nReferences Eigen Arma cpp11\nDeletar esse Tutorial_Rcpp.md Fazer README.md e colocar no exclude GitHub Pages com https\nDivulgar no discourse curso-r Divulgar no twitter marcando Dirk, Hadkey, Rcpp4everyone, clente, coatless.\n\n\n",
      "last_modified": "2021-01-10T07:44:35-03:00"
    }
  ],
  "collections": []
}
